#include "top3d_xl/geometry/isosurface.hpp"
#include <cmath>
#include <cstdint>

namespace mcube {

// Tables adapted from standard marching cubes (Lorensen & Cline)
static const int edgeTable[256] = {
0x000,0x109,0x203,0x30a,0x406,0x50f,0x605,0x70c,0x80c,0x905,0xa0f,0xb06,0xc0a,0xd03,0xe09,0xf00,
0x190,0x099,0x393,0x29a,0x596,0x49f,0x795,0x69c,0x99c,0x895,0xb9f,0xa96,0xd9a,0xc93,0xf99,0xe90,
0x230,0x339,0x033,0x13a,0x636,0x73f,0x435,0x53c,0xa3c,0xb35,0x83f,0x936,0xe3a,0xf33,0xc39,0xd30,
0x3a0,0x2a9,0x1a3,0x0aa,0x7a6,0x6af,0x5a5,0x4ac,0xbac,0xaa5,0x9af,0x8a6,0xfaa,0xea3,0xda9,0xca0,
0x460,0x569,0x663,0x76a,0x066,0x16f,0x265,0x36c,0xc6c,0xd65,0xe6f,0xf66,0x86a,0x963,0xa69,0xb60,
0x5f0,0x4f9,0x7f3,0x6fa,0x1f6,0x0ff,0x3f5,0x2fc,0xdfc,0xcf5,0xfff,0xef6,0x9fa,0x8f3,0xbf9,0xaf0,
0x650,0x759,0x453,0x55a,0x256,0x35f,0x055,0x15c,0xe5c,0xf55,0xc5f,0xd56,0xa5a,0xb53,0x859,0x950,
0x7c0,0x6c9,0x5c3,0x4ca,0x3c6,0x2cf,0x1c5,0x0cc,0xfcc,0xec5,0xdcf,0xcc6,0xbca,0xac3,0x9c9,0x8c0,
0x8c0,0x9c9,0xac3,0xbca,0xcc6,0xdcf,0xec5,0xfcc,0x0cc,0x1c5,0x2cf,0x3c6,0x4ca,0x5c3,0x6c9,0x7c0,
0x950,0x859,0xb53,0xa5a,0xd56,0xc5f,0xf55,0xe5c,0x15c,0x055,0x35f,0x256,0x55a,0x453,0x759,0x650,
0xaf0,0xbf9,0x8f3,0x9fa,0xef6,0xfff,0xcf5,0xdfc,0x2fc,0x3f5,0x0ff,0x1f6,0x6fa,0x7f3,0x4f9,0x5f0,
0xb60,0xa69,0x963,0x86a,0xf66,0xe6f,0xd65,0xc6c,0x36c,0x265,0x16f,0x066,0x76a,0x663,0x569,0x460,
0xca0,0xda9,0xea3,0xfaa,0x8a6,0x9af,0xaa5,0xbac,0x4ac,0x5a5,0x6af,0x7a6,0x0aa,0x1a3,0x2a9,0x3a0,
0xd30,0xc39,0xf33,0xe3a,0x936,0x83f,0xb35,0xa3c,0x53c,0x435,0x73f,0x636,0x13a,0x033,0x339,0x230,
0xe90,0xf99,0xc93,0xd9a,0xa96,0xb9f,0x895,0x99c,0x69c,0x795,0x49f,0x596,0x29a,0x393,0x099,0x190,
0xf00,0xe09,0xd03,0xc0a,0xb06,0xa0f,0x905,0x80c,0x70c,0x605,0x50f,0x406,0x30a,0x203,0x109,0x000
};

// stub: triTable removed; triangles are not emitted in stub mode

static inline float interp(float isov, const std::array<float,3>& p1, const std::array<float,3>& p2, float valp1, float valp2) {
	float t = (isov - valp1) / (valp2 - valp1 + 1e-12f);
	return t;
}

void marching_cubes(const std::vector<float>& vol, int ny, int nx, int nz, float iso,
					 std::vector<std::array<float,3>>& outVerts,
					 std::vector<std::array<uint32_t,3>>& outFaces) {
	outVerts.clear(); outFaces.clear();
	// To keep compact, use a naive per-cell triangulation; no dedup of vertices
	for (int z=0; z<nz-1; ++z) {
		for (int x=0; x<nx-1; ++x) {
			for (int y=0; y<ny-1; ++y) {
				int idx[8] = {
					y + ny*x + ny*nx*z,
					y + 1 + ny*x + ny*nx*z,
					y + 1 + ny*(x+1) + ny*nx*z,
					y + ny*(x+1) + ny*nx*z,
					y + ny*x + ny*nx*(z+1),
					y + 1 + ny*x + ny*nx*(z+1),
					y + 1 + ny*(x+1) + ny*nx*(z+1),
					y + ny*(x+1) + ny*nx*(z+1)
				};
				float val[8]; for (int i=0;i<8;i++) val[i]=vol[idx[i]];
				int cubeindex=0; for (int i=0;i<8;i++) if (val[i] < iso) cubeindex |= (1<<i);
				int edges = edgeTable[cubeindex]; if (!edges) continue;
				std::array<std::array<float,3>,12> vertList;
				auto pos = [&](int yy,int xx,int zz){ return std::array<float,3>{(float)xx,(float)yy,(float)zz}; };
				std::array<std::array<float,3>,8> p = { pos(y,x,z), pos(y+1,x,z), pos(y+1,x+1,z), pos(y,x+1,z), pos(y,x,z+1), pos(y+1,x,z+1), pos(y+1,x+1,z+1), pos(y,x+1,z+1) };
				auto lerp = [&](int a,int b,int e){ float t=interp(iso,p[a],p[b],val[a],val[b]); std::array<float,3> r; for(int k=0;k<3;k++) r[k]=p[a][k]+t*(p[b][k]-p[a][k]); vertList[e]=r; };
				if (edges & 1) lerp(0,1,0);
				if (edges & 2) lerp(1,2,1);
				if (edges & 4) lerp(2,3,2);
				if (edges & 8) lerp(3,0,3);
				if (edges & 16) lerp(4,5,4);
				if (edges & 32) lerp(5,6,5);
				if (edges & 64) lerp(6,7,6);
				if (edges & 128) lerp(7,4,7);
				if (edges & 256) lerp(0,4,8);
				if (edges & 512) lerp(1,5,9);
				if (edges & 1024) lerp(2,6,10);
				if (edges & 2048) lerp(3,7,11);
			// stub: triangles disabled
			}
		}
	}
}

}


