#ifndef IO_EXPORT_HPP
#define IO_EXPORT_HPP

#include <vector>
#include <string>
#include <array>
#include <fstream>
#include <cstring>
#include <cstdint>

namespace ioexp {

// Write binary STL from triangle soup
inline bool write_stl_binary(const std::string& path,
					  const std::vector<std::array<float,3>>& vertices,
					  const std::vector<std::array<uint32_t,3>>& faces) {
	std::ofstream os(path, std::ios::binary);
	if (!os) return false;
	char header[80]; std::memset(header, 0, 80); std::strncpy(header, "Generated by TOP3D_XL", 79);
	os.write(header, 80);
	uint32_t ntri = static_cast<uint32_t>(faces.size());
	os.write(reinterpret_cast<const char*>(&ntri), 4);
	for (auto f : faces) {
		float n[3] = {0,0,0};
		os.write(reinterpret_cast<char*>(n), 12);
		for (int i=0;i<3;i++) {
			auto v = vertices[f[i]];
			os.write(reinterpret_cast<const char*>(&v[0]), 12);
		}
		uint16_t attr = 0; os.write(reinterpret_cast<char*>(&attr), 2);
	}
	return true;
}

// Minimal NIfTI-1 float32 writer
struct NiftiHeader {
	int32_t sizeof_hdr; char data_type[10]; char db_name[18]; int32_t extents; int16_t session_error; char regular; char dim_info;
	int16_t dim[8]; float intent_p1,intent_p2,intent_p3; int16_t intent_code; int16_t datatype; int16_t bitpix; int16_t slice_start; float pixdim[8]; float vox_offset; float scl_slope; float scl_inter; int16_t slice_end; char slice_code; char xyzt_units; float cal_max; float cal_min; float slice_duration; float toffset; int32_t glmax; int32_t glmin; char descrip[80]; char aux_file[24]; int16_t qform_code; int16_t sform_code; float quatern_b,quatern_c,quatern_d, qoffset_x,qoffset_y,qoffset_z; float srow_x[4], srow_y[4], srow_z[4]; char intent_name[16]; char magic[4];
};

inline bool write_nifti_float32(const std::string& path,
						  int dimX, int dimY, int dimZ,
						  float sx, float sy, float sz,
						  const std::vector<float>& data) {
	std::ofstream os(path, std::ios::binary);
	if (!os) return false;
	NiftiHeader h{}; std::memset(&h, 0, sizeof(h));
	h.sizeof_hdr = 348;
	h.dim[0]=3; h.dim[1]=dimX; h.dim[2]=dimY; h.dim[3]=dimZ; h.dim[4]=1; h.dim[5]=1; h.dim[6]=1; h.dim[7]=1;
	h.datatype = 16; h.bitpix = 32;
	h.pixdim[0]=1; h.pixdim[1]=sx; h.pixdim[2]=sy; h.pixdim[3]=sz; h.pixdim[4]=1; h.pixdim[5]=1; h.pixdim[6]=1; h.pixdim[7]=1;
	h.vox_offset = 352.0f;
	std::strncpy(h.magic, "n+1\0", 4);
	os.write(reinterpret_cast<const char*>(&h), sizeof(h));
	// 4-byte extension flag (all zeros)
	uint8_t ext[4] = {0,0,0,0}; os.write(reinterpret_cast<char*>(ext), 4);
	// Data
	os.write(reinterpret_cast<const char*>(data.data()), data.size()*sizeof(float));
	return true;
}

} // namespace ioexp

#endif



