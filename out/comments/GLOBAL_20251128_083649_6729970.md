PARAMETERS
original dims: x=60, y=30, z=30
padded dims: x=64, y=32, z=32
v0: 0.12

SOLVING
iterations: 30
cg iterations: 800

RESULTS
compliance solid: 1.172298e+00
objective first: 6.780217e+02
objective last: 1.240705e+01

TIME
total solver time: 1.267340e+02
time per iter: 4.2494
percentage time spent on cg: 99.41%
percentage time spent on optim: 0.58%
percentage time spent on filtering: 0.21%

THREADS
1

NOTES
Instead of: 

for (int i = 0; i < 24; ++i) {
    const double* __restrict__ Ki = KptrAligned + 24*i;
    double sum = 0.0;
    #pragma omp simd reduction(+:sum)
    for (int j = 0; j < 24; ++j)
        sum += Ki[j] * ue[j];
    fe[i] = Ee_e * sum;
}

Now do:

const double (* __restrict__ K)[24] =
    reinterpret_cast<const double (*)[24]>(KptrAligned);

for (int i = 0; i < 24; ++i) {
    const double* __restrict__ Ki = K[i];
    double sum = 0.0;
    #pragma omp simd reduction(+:sum)
    for (int j = 0; j < 24; ++j)
        sum += Ki[j] * ue[j];
    fe[i] = Ee_e * sum;
}

In both K_times_u_finest and compute_compliance. Compiler is now given a 2D type and avoids 24*i arithmetic in hot loop. Stride-1 dimension is explicit rather than calculated.

Does have speed improvements!